<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[腾讯2017暑期实习生编程题]]></title>
    <url>%2F2018%2F05%2F22%2F%E8%85%BE%E8%AE%AF2017%2F</url>
    <content type="text"><![CDATA[构造回文时间限制：1秒 空间限制：32768K 给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回文串最长呢？输出需要删除的字符个数。 输入描述: 输入数据有多组，每组包含一个字符串s，且保证:1&lt;=s.length&lt;=1000. 输出描述: 对于每组数据，输出一个整数，代表最少需要删除的字符个数。 输入例子1:abcdagoogle 输出例子1:22 分析思路1“最少删除几个字符变成回文串”和“最少增加几个字符变成回文串”本质上一样的，不妨以增加字符的情况进行分析，设$dp[i][j]$表示由$a[i]…a[j]$构成的子串变成回文串需要增加的字符，那么 当$i \geq j$时，显然$dp[i][j] = 0$; 当$i&lt;j$时，如果$a[i] = a[j]$，则$dp[i][j] = dp[i+1][j-1]$，此时$a[i]…a[j]$变成回文串需要增加的字符数和$a[i+1]…a[j-1]$一样。 当$i&lt;j$时，如果$a[i] \neq a[j]$，则$dp[i][j] = min(dp[i+1][j], dp[i][j-1])$。 思路2最少增加的字符 = 字符串长度 - LCS(字符串，字符串倒序) 实现实现1123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000+10;int res[N][N];string s;int main()&#123; while(cin &gt;&gt; s) &#123; int len = s.length(); memset(res, 0, sizeof(res)); for(int j = 0; j &lt; len; j++) &#123; for(int i = j-1; i &gt;= 0; i--) &#123; if(s[i] == s[j]) res[i][j] = res[i+1][j-1]; else res[i][j] = min(res[i+1][j], res[i][j-1])+1; &#125; &#125; printf("%d\n", res[0][len-1]); &#125; return 0;&#125; 实现212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000+10;string s;int len;int res[N][N];int LCS(string a, string b, int len);int main()&#123; while(cin &gt;&gt; s) &#123; string t = s; len = s.length(); reverse(s.begin(), s.end()); //cout &lt;&lt; LCS(s, t, len) &lt;&lt; endl; printf("%d\n", len - LCS(s, t, len)); &#125; return 0;&#125;int LCS(string a, string b, int len)&#123; memset(res, 0, sizeof(res)); for(int i = 0; i &lt;= len; i++) &#123; for(int j = 0; j &lt;= len; j++) &#123; if(i == 0 || j == 0) &#123; res[i][j] = 0; &#125; else &#123; if(a[i-1] == b[j-1]) res[i][j] = res[i-1][j-1]+1; else res[i][j] = max(res[i-1][j], res[i][j-1]); &#125; &#125; &#125; return res[len][len];&#125; 算法基础-字符移位时间限制：1秒 空间限制：32768K 小Q最近遇到了一个难题：把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，且不能申请额外的空间。你能帮帮小Q吗？ 输入描述: 输入数据有多组，每组包含一个字符串s，且保证:1&lt;=s.length&lt;=1000. 输出描述: 对于每组数据，输出移位后的字符串。 输入例子1:AkleBiCeilD 输出例子1:kleieilABCD 分析注意不申请额外空间 实现12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string.h&gt;using namespace std;string s;int main()&#123; while(cin &gt;&gt; s) &#123; int len = s.length(); int add = 0; for(int i = 0; i &lt; len; i++) &#123; if(s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') &#123; s.push_back(s[i]); add++; &#125; else printf("%c", s[i]); &#125; cout &lt;&lt; s.substr(len, add) &lt;&lt; endl; &#125; return 0;&#125; 有趣的数字时间限制：1秒 空间限制：32768K 小Q今天在上厕所时想到了这个问题：有n个数，两两组成二元组，差最小的有多少对呢？差最大呢？ 输入描述: 输入包含多组测试数据。 对于每组测试数据： N - 本组测试数据有n个数 a1,a2…an - 需要计算的数据 保证: 1&lt;=N&lt;=100000,0&lt;=ai&lt;=INT_MAX. 输出描述: 对于每组数据，输出两个数，第一个数表示差最小的对数，第二个数表示差最大的对数。 输入例子1:645 12 45 32 5 6 输出例子1:1 2 分析对含n个整数的数组进行排序，主要分以下情况： 所有数字都相同，此时差最小对数 = 差最大对数 = $n(n-1)/2$ 存在相同数字，假设有m种相同数字，每种数字对应的个数为m-&gt;num，则差最小对数为每种数字的(m-&gt;num) ((m-&gt;num)-1)相加。差最大对数 = 最后一个数字的个数 第一个数字的个数。 所有数字都不同，差最小值一定是在相邻数字间产生的，直接扫一遍看看最小差值是多少，再扫一遍统计等于最小差值的个数。 差最大对数 = 最后一个数字的个数 * 第一个数字的个数。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;const int N = 100000 + 10;int a[N], n;int minres, maxres;int main()&#123; while(scanf("%d", &amp;n) == 1) &#123; memset(a, 0, sizeof(a)); minres = maxres = 0; map&lt;int, int&gt; mp; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;a[i]); mp[a[i]]++; &#125; sort(a, a+n); if(a[n-1] - a[0] == 0) &#123; minres = maxres = n*(n-1)/2; printf("%d %d\n", minres, maxres); continue; &#125; maxres = mp[a[n-1]] * mp[a[0]]; map&lt;int, int&gt;::iterator it = mp.begin(); for(; it != mp.end(); it++) &#123; int tmp = it -&gt; second; minres += tmp * (tmp-1) / 2; &#125; if(minres == 0) &#123; int mini = a[n-1] - a[0]; for(int i = 1; i &lt; n; i++) &#123; if(a[i] - a[i-1] &lt; mini) mini = a[i] - a[i-1]; &#125; for(int i = 1; i &lt; n; i++) &#123; if(a[i] - a[i-1] == mini) minres += mp[a[i]] * mp[a[i-1]]; &#125; &#125; printf("%d %d\n", minres, maxres); &#125; return 0;&#125;]]></content>
      <categories>
        <category>编程题</category>
      </categories>
      <tags>
        <tag>腾讯</tag>
        <tag>实习</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爱奇艺2018春招Java工程师编程题 C++版题解]]></title>
    <url>%2F2018%2F05%2F17%2F%E7%88%B1%E5%A5%87%E8%89%BA2018%E6%98%A5%E6%8B%9BJava%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BC%96%E7%A8%8B%E9%A2%98-C-%E7%89%88%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[字典序最大子序列题目描述对于字符串a和b,如果移除字符串a中的一些字母(可以全部移除,也可以一个都不移除)就能够得到字符串b我们就称b是a的子序列。 例如.”heo”是”hello”的子序列，而”xl”不是。对于给定的一个字符串s，请计算出s的字典序最大的子序列。 输入描述: 输入包括一行,一个字符串s,字符串a长度Length(1 &lt;= 1ength &lt;= 50).s中每个字符都是小写字母输出描述: 输出一个字符串,即a的字典序最大的子序列。示例 输入test 输出tt 思路在遍历字符串每个字符的过程中，如果当前字符x大于前面子串str对应最大子序列中的某一个字符y，那么从只保留字符y前的子串nstr（不包括字符y），并且将字符x拼接到新的子串nstr后；否则直接将字符x拼接到子串str后。以实例分析，比如输入字符串test，处理过程如下： 初始化子串str = “t” 开始从第二个字符’e’到最后一个字符’t’的遍历 到第二个字符’e’，因为’e’不大于’t’，所以直接拼接到str后，此时str = “te” 到第三个字符’s’，因为’s’大于子串”te”对应最大子序列str = “te”中的字符’e’，所以只保留e之前的子串”t”，并把’s’拼接到’t’后，此时str = “ts” 到第四个字符’t’，因为’t’大于子串”tes”对应最大子序列str = “ts”中的字符’s’，所以只保留e之前的子串”t”，并把’t’拼接到’t’后，此时str = “tt” 输出最终结果，”test”字典序最大的子序列为”tt” 实现1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N = 55;string s;string res;int len = 0;int main()&#123; while(cin &gt;&gt; s) &#123; len = s.length(); res.push_back(s[0]); for(int i = 1; i &lt; len; i++) &#123; int nlen = res.length(); for(int j = 1; j &lt; nlen; j++) &#123; if(s[i] &gt; res[j]) &#123; res = res.substr(0, j); break; &#125; &#125; res.push_back(s[i]); &#125; cout &lt;&lt; res &lt;&lt; endl; s.clear(); res.clear(); &#125; return 0;&#125; 三个整数题目描述牛牛有三个整数X, Y, Z.牛牛现在要使用若干次操作让X, Y, Z变为相等,每次操作牛牛有两种操作类型可选 操作1:从X, Y, Z中选择两个数,都加1 操作2:从X, Y, Z中选择一个数,加2 牛牛已经证明了使用若干次这两种操作一定可以让三个整数变为相等,请你帮他计算一下最少需要多少次操作. 输入描述: 输入包括三个整数A, B, C(0 &lt; A , B , C &lt; 100)。输出描述: 输出一个整数,表示最少需要的操作次数. 示例 输入2 5 4 输出2 思路当时在想，根据输入会有以下几种情况： x、y、z全为偶数 x、y、z全为奇数 两偶一奇 一偶两奇不如将三个数字排序(num1 &lt; num2 &lt; num3)，那么会有以下情况： 三个偶数（情况1） 三个奇数（情况2） 两个偶数一个奇数 奇数排序在第三，两偶在前（情况3） 奇数排序在第一位或者第二位（情况4） 一个偶数两个奇数 偶数排序在第三，两奇在前（情况5） 偶数排序在第一位或者第二位（情况6） 对于情况1、2、3、5，最少操作次数 = (num3-num1+num3-num2)/2对于情况4、6，讨论情况4中奇数排序在第一的情况，这个时候，需要对第二位和第三位的数字采取第一个操作，即全加1，变成奇数，此时三个数字变成情况2，最少操作次数 = 1+[(num3+1)-num1+(num3+1)-(num2+1)]/2 = (2*num2 - num1-num2)/2+1。其他情况目的也是转换到情况1、2、4、5，但是多了个第一个操作，故而+1。 实现12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N = 3;int a[N];int main()&#123; while(scanf("%d%d%d", &amp;a[0], &amp;a[1], &amp;a[2]) != EOF) &#123; sort(a, a+3); if((a[2] - a[1] + a[2] - a[0]) % 2 == 0) &#123; printf("%d\n", (2*a[2] - a[0] - a[1])/2); &#125; else &#123; printf("%d\n", (2*a[2] - a[0] - a[1] + 1)/2 + 1); &#125; &#125; return 0;&#125; 牛牛配糖果题目描述牛牛有n种糖果,每种糖果都有足够多,现在牛牛想用这些糖果组成一些糖果盒. 每个糖果盒内放m个糖果,对于一个糖果盒牛牛希望第种糖果的数量不能少于li颗,也不能多于ri颗. 满足条件的糖果盒组成方案可能会有很多,牛牛希望你帮他计算一共有多少种糖果盒的拼凄方案. 对于两种方案,当有任意一种糖果个数不同,就视为两种不同方案. 输入描述: 输入包括n+1行。第一行包括两个正整数(1&lt;=n&lt;= 20, 1&lt;=m&lt;= 100),表示糖果的种数和一盒糖果盒的糖果个数。接下来的n行,每行两个整数li, ri(0&lt; li&lt; ri &lt;= 10),表示第i种糖果的数量限制上下限。输出描述： 输出一个整数，表示满足限定条件的方案数。保证答案在64位整数范围内。 示例 输入3 50 30 30 3 输出12 思路开始打算采用dfs写，但是写崩了。这题没有自己做出来，参考了别人的dp写法，想了一下。这道题意思是问有多少种满足条件的糖果放置方法，每种糖果都有放置数目的上下界，我们只需要考虑在完全满足下界下，有多少种方案就可以了，就像代码里sum = m - least。对于第i种糖果、当前盒子容量为j的情况下，如果第i-1种糖果占用的空间k不比j大，意味着现在可以放入第i种糖果，更新方案个数dp[i][j] += dp[i-1][j-k]。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;using namespace std;typedef long long ll;const int N = 20 + 5;const int M = 100 + 5;int a[N][2];int avail[N]; ll res[N][M];int least = 0, sum = 0, n, m;int main()&#123; //n表示糖果种类，m表示盒子要装多少糖果 while(scanf("%d%d", &amp;n, &amp;m) == 2) &#123; //输入两个值，分别表示第i类糖果最少多少个和最多多少个 for(int i = 0; i &lt; n; i++) &#123; scanf("%d%d", &amp;a[i][0], &amp;a[i][1]); least += a[i][0]; avail[i] = a[i][1] - a[i][0]; &#125; memset(res, 0, sizeof(res)); for(int i = 0; i &lt; n; i++) &#123; res[i][0] = 1; &#125; sum = m - least; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= sum; j++) &#123; for(int k = 0; k &lt;= avail[i-1]; k++) &#123; if(k &lt;= j) res[i][j] += res[i-1][j-k]; &#125; &#125; &#125; printf("%d\n", res[n][sum]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>编程题</category>
      </categories>
      <tags>
        <tag>实习</tag>
        <tag>C++</tag>
        <tag>爱奇艺</tag>
        <tag>春招</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统调用]]></title>
    <url>%2F2018%2F05%2F12%2F%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[系统调用基本原理系统调用其实就是函数调用，区别是调用内核态的函数。但是用户态到内核态不是随意切换的，所以通过系统调用接口实现用户态到内核态的切换，在保护机制的计算机系统中，用户必须通过软件中断或陷入的方式使进程从用户态切换为内核态。在i386体系中，Linux系统调用接口是通过软中断指令int 0x80使进程从用户态进入内核态的，这个过程也叫“陷入”。系统调用接口调用软中断指令int 0x80的时候，这个指令会发生一个中断向量码为128的中断请求，并在响应过程中将进程从用户态切换为内核态。通过软中断0x80，系统会跳转到一个预设好的内核空间地址，它指向了系统调用处理程序，即在entry.S文件中的system_call函数。也就是，所有的系统调用都会统一跳转到这个地址执行system_call()函数。因为Linux只允许系统调用接口使用128这一个中断向量，并在中断号为128的中断服务例程中，调用不同调用不同的内核服务例程，所以，系统调用接口除了要引发int 0x80软中断外，为了进入内河后调用不同的内核服务例程，还需要提供识别内核服务例程的参数，称之为“系统调用号”。每个系统调用都有对应的系统调用号，同时内核中有一个system_call_table数组，它是个函数指针数组，每个函数指针都指向了系统调用的服务例程，下标就是该内核服务例程的系统调用号，用以指明到底执行哪个系统调用。当int 0x80软中断执行时，系统调用号会放入eax寄存器中，system_call函数可以读取eax寄存器获得系统调用号，将其乘以4得到偏移地址，以sys_call_table为基地址，基地址加上偏移地址就是应该执行的系统调用服务例程（内核服务例程）的地址。 系统调用参数传递参数依次存放在寄存器eax、ebx、ecx、edx、esi中，当系统调用的参数大于5个时（因为上面5个寄存器用完了），执行int 0x80执行仍需将系统调用功能号保存在eax中，所不同的只是参数应该依次存放在一块连续的内存区域内，同时在寄存器eax中保存指向该内存区域的指针。系统调用完成后，返回值仍将保存在寄存器eax中。由于只是需要一块连续的内存区域来保存系统调用的参数，因此可以完全像普通函数调用一样使用栈（Stack）来传递系统调用所需的参数。但是，注意参数以相反的顺序进栈，先进后出，即应该最后一个参数先进栈，第一个参数最后进栈。如果采用栈来传递系统调用所需要的参数，在执行int $0x80指令时还应该将栈指针的当前值复制到寄存器ebx中。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>系统调用</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核：增加系统调用]]></title>
    <url>%2F2018%2F04%2F22%2FLinux%E5%86%85%E6%A0%B8%EF%BC%9A%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[系统调用是操作系统为用户态进程与硬件及内核资源进行交互提供的一组接口。本文主要介绍如何在VMWare虚拟机下向Linux内核增加系统调用，并进行简单测试的过程。对于不同的内核版本，实现方式略有不同，这里使用的是内核4.6.3。主要有以下6个步骤： 下载并解压内核、生成.config配置文件 在arch/x86/entry/syscalls/syscall_64.tbl中添加系统调用号 在kernel/sys.c中添加系统调用程序 在include/linux/syscalls.h中添加相应的声明 编译内核、安装内核 重启并测试 下载并解压内核、生成.config配置文件下载并解压内核在清华镜像下载linux-4.6.3，解压至/usr/src，1sudo tar -xvf linux-4.6.3.tar.gz 进入该文件夹，1cd /usr/src/linux-4.6.3 生成.config配置文件.config文件是Linux内核的配置文件，执行make bzImage生成新内核的时候，顶层的Makefile文件会读取.config文件中的内容，根据这个文件编译定制的内核。首先将原来的配置文件拷贝过来，到/usr/src文件夹下，使用uname -r查看内核版本，当前的Ubuntu内核版本是4.10.0-30，配置文件是/usr/src/linux-headers-4.10.0-30-generic/.config 这个文件，执行如下命令生成临时.config配置文件：1sudo cp /usr/src/linux-headers-4.10.0-30-generic/.config .config 其他安装12sudo apt-get install libssl-devsudo apt-get install libncurses5-dev 其中libncurses5-dev安装menuconfig，与屏幕显示和游标移动相关。 添加系统调用号在arch/x86/entry/syscalls/syscall_64.tbl文件中，向最后一行添加自己的系统调用，如下1546 common lsproc sys_lsproc 添加系统调用程序在kernel/sys.c文件中，添加系统调用程序，12345asmlinkage int sys_lsproc (int num)&#123; printk("Hi, this is yuhong's syscall\n"); return 1;&#125; 添加相应声明在include/linux/syscalls.h中添加函数声明，1asmlinkage int sys_lsproc(int num); 编译内核、安装内核执行1sudo make menuconfig 选择Load，然后Ok，保存并退出。然后依次执行，1234make bzImage //生成新内核make modules //编译模块make modules_install //安装模块make install //安装内核 重启并测试安装完成之后重启虚拟机，按ESC进入Ubuntu Grub界面，选择高级选项，选择4.6.3内核。新建测试文件test.c，内容为：12345678#include &lt;linux/unistd.h&gt;#include &lt;sys/syscall.h&gt;int main()&#123; syscall(546, 1); //依次是调用号和参数 return 0;&#125; 编译并运行，输出这里提示implicit declaration of function ‘syscall’，经查暂无果。dmesg查看系统缓冲区以获取最近输出的诊断消息并在标准输出中输出这些消息。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内核</tag>
        <tag>系统调用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu make menuconfig error]]></title>
    <url>%2F2018%2F03%2F02%2F%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[1234567891011root@ubuntu:/home/linux/linux-4.15.6# make menuconfig *** Unable to find the ncurses libraries or the *** required header files. *** 'make menuconfig' requires the ncurses libraries. *** *** Install ncurses (ncurses-devel) and try again. ***scripts/kconfig/Makefile:202: recipe for target 'scripts/kconfig/dochecklxdialog' failedmake[1]: *** [scripts/kconfig/dochecklxdialog] Error 1Makefile:505: recipe for target 'menuconfig' failedmake: *** [menuconfig] Error 2 solution:1apt-get install libncurses5 libncurses5-dev]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>内核编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git笔记]]></title>
    <url>%2F2018%2F01%2F23%2FGit%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Git介绍 Git是分布式版本控制系统 集中式VS分布式，SVN VS Git1）SVN和Git主要的区别在于历史版本维护的位置2）Git本地仓库包含代码库还有历史库，在本地的环境开发就可以记录历史而SVN的历史库存在于中央仓库，每次对比与提交代码都必须连接到中央仓库才能进行。3）这样的好处在于： 自己可以在脱机环境查看开发的版本历史。 多人开发时如果充当中央仓库的Git仓库挂了，可以随时创建一个新的中央仓库然后同步就立刻恢复了中央库。 Git命令Git配置12$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com" git config命令的--global参数，表明这台机器上的所有Git仓库都会使用这个配置，也可以对某个仓库指定不同的用户名和邮箱地址。 创建版本库初始化一个Git仓库1$ git init 添加文件到Git仓库包括两步：12$ git add &lt;file&gt;$ git commit -m "description" git add可以反复多次使用，添加多个文件，git commit可以一次提交很多文件，-m后面输入的是本次提交的说明，可以输入任意内容。 查看工作区状态1$ git status 查看修改内容1$ git diff 1$ git diff --cached 1$ git diff HEAD -- &lt;file&gt; git diff 可以查看工作区(work dict)和暂存区(stage)的区别 git diff --cached 可以查看暂存区(stage)和分支(master)的区别 git diff HEAD -- &lt;file&gt; 可以查看工作区和版本库里面最新版本的区别查看提交日志1$ git log 简化日志输出信息1$ git log --pretty=oneline 查看命令历史1$ git reflog 版本回退1$ git reset --hard HEAD^ 以上命令是返回上一个版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本是HEAD^^，往上100个版本写成HEAD~100。 回退指定版本号1$ git reset --hard commit_id commit_id是版本号，是一个用SHA1计算出的序列 工作区、暂存区和版本库工作区：在电脑里能看到的目录；版本库：在工作区有一个隐藏目录.git，是Git的版本库。Git的版本库中存了很多东西，其中最重要的就是称为stage（或者称为index）的暂存区，还有Git自动创建的master，以及指向master的指针HEAD。 进一步解释一些命令： git add实际上是把文件添加到暂存区 git commit实际上是把暂存区的所有内容提交到当前分支撤销修改丢弃工作区的修改1$ git checkout -- &lt;file&gt; 该命令是指将文件在工作区的修改全部撤销，这里有两种情况： 一种是file自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是file已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 丢弃暂存区的修改分两步：第一步，把暂存区的修改撤销掉(unstage)，重新放回工作区：1$ git reset HEAD &lt;file&gt; 第二步，撤销工作区的修改1$ git checkout -- &lt;file&gt; 小结： 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- &lt;file&gt;。 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了第一步，第二步按第一步操作。 已经提交了不合适的修改到版本库时，想要撤销本次提交，进行版本回退，前提是没有推送到远程库。 删除文件1$ git rm &lt;file&gt; git rm &lt;file&gt;相当于执行12$ rm &lt;file&gt;$ git add &lt;file&gt; 进一步的解释Q：比如执行了rm text.txt 误删了怎么恢复？A：执行git checkout -- text.txt 把版本库的东西重新写回工作区就行了Q：如果执行了git rm text.txt我们会发现工作区的text.txt也删除了，怎么恢复？A：先撤销暂存区修改，重新放回工作区，然后再从版本库写回到工作区12$ git reset head text.txt$ git checkout -- text.txt Q：如果真的想从版本库里面删除文件怎么做？A：执行git commit -m &quot;delete text.txt&quot;，提交后最新的版本库将不包含这个文件 远程仓库创建SSH Key1$ ssh-keygen -t rsa -C "youremail@example.com" 关联远程仓库1$ git remote add origin https://github.com/username/repositoryname.git 推送到远程仓库1$ git push -u origin master -u 表示第一次推送master分支的所有内容，此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改。 从远程克隆1$ git clone https://github.com/usern/repositoryname.git 分支创建分支1$ git branch &lt;branchname&gt; 查看分支1$ git branch git branch命令会列出所有分支，当前分支前面会标一个*号。 切换分支1$ git checkout &lt;branchname&gt; 创建+切换分支1$ git checkout -b &lt;branchname&gt; 合并某分支到当前分支1$ git merge &lt;branchname&gt; 删除分支1$ git branch -d &lt;branchname&gt; 查看分支合并图1$ git log --graph 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。用git log --graph命令可以看到分支合并图。 普通模式合并分支1$ git merge --no-ff -m "description" &lt;branchname&gt; 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。合并分支时，加上--no-ff参数就可以用普通模式合并，能看出来曾经做过合并，包含作者和时间戳等信息，而fast forward合并就看不出来曾经做过合并。 保存工作现场1$ git stash 查看工作现场1$ git stash list 恢复工作现场1$ git stash pop 丢弃一个没有合并过的分支1$ git branch -D &lt;branchname&gt; 查看远程库信息1$ git remote -v 在本地创建和远程分支对应的分支1$ git checkout -b branch-name origin/branch-name， 本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联1$ git branch --set-upstream branch-name origin/branch-name； 从本地推送分支1$ git push origin branch-name 如果推送失败，先用git pull抓取远程的新提交； 从远程抓取分支1$ git pull 如果有冲突，要先处理冲突。 标签tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。 新建一个标签1$ git tag &lt;tagname&gt; 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id。 指定标签信息1$ git tag -a &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息。 PGP签名标签1$ git tag -s &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;可以用PGP签名标签。 查看所有标签1$ git tag 推送一个本地标签1$ git push origin &lt;tagname&gt; 推送全部未推送过的本地标签1$ git push origin --tags 删除一个本地标签1$ git tag -d &lt;tagname&gt; 删除一个远程标签1$ git push origin :refs/tags/&lt;tagname&gt;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo+GitHub Pages搭建个人博客]]></title>
    <url>%2F2018%2F01%2F19%2F%E4%BD%BF%E7%94%A8Hexo-GitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[本文主要用于记录自己搭建博客的过程。17年12月快期末的时候，萌生了下学期出去实习的想法，考试结束后这种想法愈发强烈，尝试写了简历之后很难受，发现没什么拿的出手的工作和项目，于是寒假这段时间想静下心来，先从个人博客开始，慢慢地学点知识，努力追赶优秀的吴大大、卜神、大仙等。 准备需要准备两个软件： Git Node.js 我的操作系统是Win10 64位，Mac OS和Linux请参看其他安装方式。 安装Git到官网下载Git安装文件，在“Adjusting your PATH environment”这一步时，选择第二项“User Git from the Windows Command Prompt”。安装完成后，按Win+R打开运行窗口输入cmd并回车，打开命令行窗口，输入1git --version 如果结果会显示git 版本号，说明安装正确。 配置Node.js环境到官网下载相应的Node.js文件，下载完成后打开，保持默认设置即可，一路Next。同样地，打开命令行窗口，依次输入12node -vnpm -v 如果显示相应的版本号，说明安装正确。 配置GitHub创建仓库注册后登录，创建仓库(New repository)，其中repository name为yourname.github，Description不写也没关系。 开启GitHub-Pages功能点击界面右侧的Setting，将会打开该仓库的setting界面，向下拖动直至看见GitHub Pages，点击“Automatic page generator”，GitHub将会自动创建gh-pages页面，过几分钟后，即可访问yourname.github.io这个网址。 配置Hexo安装Hexo在自己觉得合适的地方创建一个文件夹，我在桌面上新建文件夹命名为Blog，进入该空白文件夹，在此处打开Git Bash，输入1npm install hexo-cli -g 继续输入1npm install hexp --save 输入以下命令，如果显示hexo版本号说明安装成功1hexo -v 初始化Hexo接着上面的操作继续输入1hexo init blog 其中blog文件夹即为本地仓库，与博客相关的配置和博文内容都在里面1npm install 体验Hexo继续操作，同样在Git Bash下，输入1hexo g 然后，1hexp d 在浏览器中打开http://localhost:4000/，将会看到一个崭新的的博客页面。若打不开，可能是因为端口被占用了，换个端口即可，执行命令1hexo server -p 5000 上面的命令即换到端口5000，在浏览器中打开http://localhost:5000/即可。到目前为止，Hexo在本地的配置全部结束。 使用Hexo配置Deployment打开Git Bash，选择使用git方式进行部署，输入1npm install hexo-deployer-git --save 首先需要为自己配置身份信息,输入12git config --global user.name "yourname"git config --global user.email "youremail" 同样在站点文件_config.yml，找到Deployment然后按照如下修改1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 然后在进入blog文件夹下，输入1hexo d 接下来按照提示，分别输入自己的Github账号用户名和密码，然后就可以通过http://yourname.github.io/来访问自己刚上传地网站了。 添加新文章打开blog目录下的source文件夹，再打开_posts文件夹，会看到一个初始的hello-world.md文件，这就是对应的博文。如果想添加新文章，直接在_posts文件夹下新建md类型的文档即可，重新执行hexo clean、hexo g和hexo d。 进阶绑定域名在本地ping yourname.github.io后会得到一个ip：xxx.xxx.xx.147，我在阿里云上买了一个域名yuhongwa.com，然后进行解析，添加三条条目如下： 类型 主机记录 记录值 CNAME @ hongiii.github.io A @ xxx.xxx.xx.147 A @ xxx.xxx.xx.148 然后在blog目录下的source文件中华，新建一个CNAME文件，没有后缀名，内容为yourdomain.xxx，我的就是www.yuhongwa.com，然后执行1hexo d -g 重现上传自己的博客，登录Github打开yourname.github.io仓库，进入setting页面，如果在GitHub Pages下看到”Your site is published at https://www.yuhongwa.com“之类的提示，说明配置成功。 修改主题Hexo默认采用landscape主题，如果想更换其他主题比如Next等，可以查到相应的主题下载到blog目录下的theme文件夹下，然后在站点配置文件_config.yml中修改，1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: landscape //themes文件夹中对应文件夹的名称 然后执行hexo clean，接着hexo g，最后hexo d，很快就可以看到新的主题样式了。 其他个性化设置这一部分我花费的时间比较长，参考了很多文章，个性化设置有很多，比如 更改字体字号 头像设为圆形可旋转 动态页面 添加音乐 添加评论 添加打赏 添加浏览、访客之类 添加RSS等等 实在太多了，我采用的主要有以下个性化设置： 修改侧边栏为左侧默认Next主题Mist风格，侧边栏是放在右边的，我想把它放在左侧。参考 修改字号我不记得默认的字号是14px还是16px，修改字号参考 修改主题宽度默认主题的留白太多，如果想修改页宽，减少两侧空白，可参考 头像设为圆形，且点击可旋转参考注意，如果想设置为圆形，采用的图片尽量为正方形，否则显示效果为椭圆。 添加高冷的龙之介大人模型(live2d)参考 添加评论看很多人用的来必力之类的，我用的是友言，个人感觉友言挺好用的。 添加打赏等以上两部分谷歌一下都有很多，不再赘述了。 总结从开始搭建博客到完成，大概花了一周的时间，感觉大部分时间都用在个性化配置上面了，这里非常感谢很多很多的大佬们的文章和开源项目。呐，小白龙要开始她的学习之旅啦~]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github Pages</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
