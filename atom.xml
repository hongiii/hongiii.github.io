<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hongiii</title>
  
  <subtitle>yuhong&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yuhongwa.com/"/>
  <updated>2018-05-12T13:46:53.061Z</updated>
  <id>http://www.yuhongwa.com/</id>
  
  <author>
    <name>Yuhong Wa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux系统调用</title>
    <link href="http://www.yuhongwa.com/2018/04/22/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://www.yuhongwa.com/2018/04/22/系统调用/</id>
    <published>2018-04-22T13:55:00.000Z</published>
    <updated>2018-05-12T13:46:53.061Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="系统调用基本原理"><a href="#系统调用基本原理" class="headerlink" title="系统调用基本原理"></a>系统调用基本原理</h3><p>系统调用其实就是函数调用，区别是调用内核态的函数。但是用户态到内核态不是随意切换的，所以通过系统调用接口实现用户态到内核态的切换，在保护机制的计算机系统中，用户必须通过软件中断或陷入的方式使进程从用户态切换为内核态。</p><p>在i386体系中，Linux系统调用接口是通过软中断指令<code>int 0x80</code>使进程从用户态进入内核态的，这个过程也叫“陷入”。系统调用接口调用软中断指令<code>int 0x80</code>的时候，这个指令会发生一个中断向量码为128的中断请求，并在响应过程中将进程从用户态切换为内核态。</p><p>通过软中断<code>0x80</code>，系统会跳转到一个预设好的内核空间地址，它指向了系统调用处理程序，即在entry.S文件中的system_call函数。也就是，所有的系统调用都会统一跳转到这个地址执行system_call()函数。</p><p>因为Linux只允许系统调用接口使用128这一个中断向量，并在中断号为128的中断服务例程中，调用不同调用不同的内核服务例程，所以，系统调用接口除了要引发<code>int 0x80</code>软中断外，为了进入内河后调用不同的内核服务例程，还需要提供识别内核服务例程的参数，称之为“系统调用号”。</p><p>每个系统调用都有对应的系统调用号，同时内核中有一个system_call_table数组，它是个函数指针数组，每个函数指针都指向了系统调用的服务例程，下标就是该内核服务例程的系统调用号，用以指明到底执行哪个系统调用。当<code>int 0x80</code>软中断执行时，系统调用号会放入<code>eax</code>寄存器中，system_call函数可以读取<code>eax</code>寄存器获得系统调用号，将其乘以4得到偏移地址，以sys_call_table为基地址，基地址加上偏移地址就是应该执行的系统调用服务例程（内核服务例程）的地址。</p><h3 id="系统调用参数传递"><a href="#系统调用参数传递" class="headerlink" title="系统调用参数传递"></a>系统调用参数传递</h3><p>参数依次存放在寄存器<code>eax</code>、<code>ebx</code>、<code>ecx</code>、<code>edx</code>、<code>esi</code>中，当系统调用的参数大于5个时（因为上面5个寄存器用完了），执行<code>int 0x80</code>执行仍需将系统调用功能号保存在<code>eax</code>中，所不同的只是参数应该依次存放在一块连续的内存区域内，同时在寄存器<code>eax</code>中保存指向该内存区域的指针。系统调用完成后，返回值仍将保存在寄存器<code>eax</code>中。由于只是需要一块连续的内存区域来保存系统调用的参数，因此可以完全像普通函数调用一样使用栈（Stack）来传递系统调用所需的参数。但是，注意参数以相反的顺序进栈，先进后出，即应该最后一个参数先进栈，第一个参数最后进栈。如果采用栈来传递系统调用所需要的参数，在执行<code>int $0x80</code>指令时还应该将栈指针的当前值复制到寄存器<code>ebx</code>中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;系统调用基本原理&quot;&gt;&lt;a href=&quot;#系统调用基本原理&quot; class=&quot;headerlink&quot; title=&quot;系统调用基本原理&quot;&gt;&lt;/a&gt;系统调用基本原理&lt;/h3
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.yuhongwa.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.yuhongwa.com/tags/Linux/"/>
    
      <category term="中断" scheme="http://www.yuhongwa.com/tags/%E4%B8%AD%E6%96%AD/"/>
    
      <category term="系统调用" scheme="http://www.yuhongwa.com/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核：增加系统调用</title>
    <link href="http://www.yuhongwa.com/2018/04/22/Linux%E5%86%85%E6%A0%B8%EF%BC%9A%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://www.yuhongwa.com/2018/04/22/Linux内核：增加系统调用/</id>
    <published>2018-04-22T13:55:00.000Z</published>
    <updated>2018-04-23T09:40:11.646Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>系统调用是操作系统为用户态进程与硬件及内核资源进行交互提供的一组接口。<br>本文主要介绍如何在VMWare虚拟机下向Linux内核增加系统调用，并进行简单测试的过程。对于不同的内核版本，实现方式略有不同，这里使用的是内核4.6.3。<br>主要有以下6个步骤：</p><ul><li>下载并解压内核、生成<code>.config</code>配置文件</li><li>在<code>arch/x86/entry/syscalls/syscall_64.tbl</code>中添加系统调用号</li><li>在<code>kernel/sys.c</code>中添加系统调用程序</li><li>在<code>include/linux/syscalls.h</code>中添加相应的声明</li><li>编译内核、安装内核</li><li>重启并测试</li></ul><h3 id="下载并解压内核、生成-config配置文件"><a href="#下载并解压内核、生成-config配置文件" class="headerlink" title="下载并解压内核、生成.config配置文件"></a>下载并解压内核、生成<code>.config</code>配置文件</h3><h4 id="下载并解压内核"><a href="#下载并解压内核" class="headerlink" title="下载并解压内核"></a>下载并解压内核</h4><p>在<a href="https://mirrors.tuna.tsinghua.edu.cn/kernel/" target="_blank" rel="noopener">清华镜像</a>下载linux-4.6.3，解压至/usr/src，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -xvf linux-4.6.3.tar.gz</span><br></pre></td></tr></table></figure></p><p>进入该文件夹，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src/linux-4.6.3</span><br></pre></td></tr></table></figure></p><h4 id="生成-config配置文件"><a href="#生成-config配置文件" class="headerlink" title="生成.config配置文件"></a>生成<code>.config</code>配置文件</h4><p><b><code>.config</code>文件是Linux内核的配置文件，执行<code>make bzImage</code>生成新内核的时候，顶层的Makefile文件会读取<code>.config</code>文件中的内容，根据这个文件编译定制的内核。</b><br>首先将原来的配置文件拷贝过来，到/usr/src文件夹下，使用<code>uname -r</code>查看内核版本，当前的Ubuntu内核版本是4.10.0-30，配置文件是<code>/usr/src/linux-headers-4.10.0-30-generic/.config 这个文件</code>，执行如下命令生成临时.config配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /usr/src/linux-headers-4.10.0-30-generic/.config .config</span><br></pre></td></tr></table></figure></p><h4 id="其他安装"><a href="#其他安装" class="headerlink" title="其他安装"></a>其他安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libssl-dev</span><br><span class="line">sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure><p>其中<code>libncurses5-dev</code>安装menuconfig，与屏幕显示和游标移动相关。</p><h3 id="添加系统调用号"><a href="#添加系统调用号" class="headerlink" title="添加系统调用号"></a>添加系统调用号</h3><p>在<code>arch/x86/entry/syscalls/syscall_64.tbl</code>文件中，向最后一行添加自己的系统调用，如下<img src="https://github.com/hongiii/mdPic/blob/master/aboutBlog/linux%E5%86%85%E6%A0%B8%EF%BC%9A%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/n1.PNG?raw=true" alt="image"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">546   common    lsproc      sys_lsproc</span><br></pre></td></tr></table></figure></p><h3 id="添加系统调用程序"><a href="#添加系统调用程序" class="headerlink" title="添加系统调用程序"></a>添加系统调用程序</h3><p>在<code>kernel/sys.c</code>文件中，添加系统调用程序，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_lsproc</span> <span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"Hi, this is yuhong's syscall\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://github.com/hongiii/mdPic/blob/master/aboutBlog/linux%E5%86%85%E6%A0%B8%EF%BC%9A%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/n2.PNG?raw=true" alt="image"></p><h3 id="添加相应声明"><a href="#添加相应声明" class="headerlink" title="添加相应声明"></a>添加相应声明</h3><p>在<code>include/linux/syscalls.h</code>中添加函数声明，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_lsproc</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure></p><p><img src="https://github.com/hongiii/mdPic/blob/master/aboutBlog/linux%E5%86%85%E6%A0%B8%EF%BC%9A%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/n3.PNG?raw=true" alt="image"></p><h3 id="编译内核、安装内核"><a href="#编译内核、安装内核" class="headerlink" title="编译内核、安装内核"></a>编译内核、安装内核</h3><p>执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make menuconfig</span><br></pre></td></tr></table></figure></p><p>选择Load，然后Ok，保存并退出。<br><img src="https://github.com/hongiii/mdPic/blob/master/aboutBlog/linux%E5%86%85%E6%A0%B8%EF%BC%9A%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/n4.PNG?raw=true" alt="image"><br><img src="https://github.com/hongiii/mdPic/blob/master/aboutBlog/linux%E5%86%85%E6%A0%B8%EF%BC%9A%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/n5.PNG?raw=true" alt="image"><br>然后依次执行，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make bzImage //生成新内核</span><br><span class="line">make modules //编译模块</span><br><span class="line">make modules_install //安装模块</span><br><span class="line">make install //安装内核</span><br></pre></td></tr></table></figure></p><h3 id="重启并测试"><a href="#重启并测试" class="headerlink" title="重启并测试"></a>重启并测试</h3><p>安装完成之后重启虚拟机，按ESC进入Ubuntu Grub界面，选择高级选项，选择4.6.3内核。<br>新建测试文件test.c，内容为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    syscall(<span class="number">546</span>, <span class="number">1</span>); <span class="comment">//依次是调用号和参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译并运行，输出<br><img src="https://github.com/hongiii/mdPic/blob/master/aboutBlog/linux%E5%86%85%E6%A0%B8%EF%BC%9A%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/N6.PNG?raw=true" alt="image"><br>这里提示implicit declaration of function ‘syscall’，经查暂无果。<code>dmesg</code>查看系统缓冲区以获取最近输出的诊断消息并在标准输出中输出这些消息。<br><img src="https://github.com/hongiii/mdPic/blob/master/aboutBlog/linux%E5%86%85%E6%A0%B8%EF%BC%9A%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/N7.PNG?raw=true" alt="image"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;系统调用是操作系统为用户态进程与硬件及内核资源进行交互提供的一组接口。&lt;br&gt;本文主要介绍如何在VMWare虚拟机下向Linux内核增加系统调用，并进行简单测试的过程。对于不
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.yuhongwa.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.yuhongwa.com/tags/Linux/"/>
    
      <category term="系统调用" scheme="http://www.yuhongwa.com/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="内核" scheme="http://www.yuhongwa.com/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu make menuconfig error</title>
    <link href="http://www.yuhongwa.com/2018/03/02/%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF/"/>
    <id>http://www.yuhongwa.com/2018/03/02/内核编译错误/</id>
    <published>2018-03-02T13:49:00.000Z</published>
    <updated>2018-04-23T09:40:16.542Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/linux/linux-4.15.6<span class="comment"># make menuconfig</span></span><br><span class="line"> *** Unable to find the ncurses libraries or the</span><br><span class="line"> *** required header files.</span><br><span class="line"> *** <span class="string">'make menuconfig'</span> requires the ncurses libraries.</span><br><span class="line"> ***</span><br><span class="line"> *** Install ncurses (ncurses-devel) and try again.</span><br><span class="line"> ***</span><br><span class="line">scripts/kconfig/Makefile:202: recipe <span class="keyword">for</span> target <span class="string">'scripts/kconfig/dochecklxdialog'</span> failed</span><br><span class="line">make[1]: *** [scripts/kconfig/dochecklxdialog] Error 1</span><br><span class="line">Makefile:505: recipe <span class="keyword">for</span> target <span class="string">'menuconfig'</span> failed</span><br><span class="line">make: *** [menuconfig] Error 2</span><br></pre></td></tr></table></figure><p>solution:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install  libncurses5 libncurses5-dev</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.yuhongwa.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.yuhongwa.com/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="http://www.yuhongwa.com/tags/Ubuntu/"/>
    
      <category term="内核编译" scheme="http://www.yuhongwa.com/tags/%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Git笔记</title>
    <link href="http://www.yuhongwa.com/2018/01/23/Git%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.yuhongwa.com/2018/01/23/Git笔记/</id>
    <published>2018-01-22T19:50:00.000Z</published>
    <updated>2018-02-02T16:04:47.928Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h2><ul><li>Git是分布式版本控制系统</li><li>集中式VS分布式，SVN VS Git<br>1）SVN和Git主要的区别在于历史版本维护的位置<br>2）Git本地仓库包含代码库还有历史库，在本地的环境开发就可以记录历史而SVN的历史库存在于中央仓库，每次对比与提交代码都必须连接到中央仓库才能进行。<br>3）这样的好处在于：<ul><li>自己可以在脱机环境查看开发的版本历史。</li><li>多人开发时如果充当中央仓库的Git仓库挂了，可以随时创建一个新的中央仓库然后同步就立刻恢复了中央库。</li></ul></li></ul><h2 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h2><h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure><p><code>git config</code>命令的<code>--global</code>参数，表明这台机器上的所有Git仓库都会使用这个配置，也可以对某个仓库指定不同的用户名和邮箱地址。</p><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><h4 id="初始化一个Git仓库"><a href="#初始化一个Git仓库" class="headerlink" title="初始化一个Git仓库"></a>初始化一个Git仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><h4 id="添加文件到Git仓库"><a href="#添加文件到Git仓库" class="headerlink" title="添加文件到Git仓库"></a>添加文件到Git仓库</h4><p>包括两步：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add &lt;file&gt;</span><br><span class="line">$ git commit -m <span class="string">"description"</span></span><br></pre></td></tr></table></figure></p><p><code>git add</code>可以反复多次使用，添加多个文件，<code>git commit</code>可以一次提交很多文件，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容。</p><h3 id="查看工作区状态"><a href="#查看工作区状态" class="headerlink" title="查看工作区状态"></a>查看工作区状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><h3 id="查看修改内容"><a href="#查看修改内容" class="headerlink" title="查看修改内容"></a>查看修改内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD -- &lt;file&gt;</span><br></pre></td></tr></table></figure><ul><li><code>git diff</code> 可以查看工作区(work dict)和暂存区(stage)的区别</li><li><code>git diff --cached</code> 可以查看暂存区(stage)和分支(master)的区别</li><li><code>git diff HEAD -- &lt;file&gt;</code> 可以查看工作区和版本库里面最新版本的区别<h3 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></li></ul><p>简化日志输出信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></table></figure></p><h3 id="查看命令历史"><a href="#查看命令历史" class="headerlink" title="查看命令历史"></a>查看命令历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>以上命令是返回上一个版本，在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本是<code>HEAD^^</code>，往上100个版本写成<code>HEAD~100</code>。</p><h3 id="回退指定版本号"><a href="#回退指定版本号" class="headerlink" title="回退指定版本号"></a>回退指定版本号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard commit_id</span><br></pre></td></tr></table></figure><p>commit_id是版本号，是一个用SHA1计算出的序列</p><h3 id="工作区、暂存区和版本库"><a href="#工作区、暂存区和版本库" class="headerlink" title="工作区、暂存区和版本库"></a>工作区、暂存区和版本库</h3><p>工作区：在电脑里能看到的目录；<br>版本库：在工作区有一个隐藏目录<code>.git</code>，是Git的版本库。<br>Git的版本库中存了很多东西，其中最重要的就是称为stage（或者称为index）的暂存区，还有Git自动创建的<code>master</code>，以及指向<code>master</code>的指针<code>HEAD</code>。</p><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907720458e56751df1c474485b697575073c40ae9000/0" alt="理解"></p><p>进一步解释一些命令：</p><ul><li><code>git add</code>实际上是把文件添加到暂存区</li><li><code>git commit</code>实际上是把暂存区的所有内容提交到当前分支<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><h4 id="丢弃工作区的修改"><a href="#丢弃工作区的修改" class="headerlink" title="丢弃工作区的修改"></a>丢弃工作区的修改</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure></li></ul><p>该命令是指将文件在工作区的修改全部撤销，这里有两种情况：</p><ol><li>一种是file自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>一种是file已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li></ol><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p><h4 id="丢弃暂存区的修改"><a href="#丢弃暂存区的修改" class="headerlink" title="丢弃暂存区的修改"></a>丢弃暂存区的修改</h4><p>分两步：<br>第一步，把暂存区的修改撤销掉(unstage)，重新放回工作区：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure></p><p>第二步，撤销工作区的修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure></p><p>小结：</p><ol><li>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- &lt;file&gt;</code>。</li><li><p>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了第一步，第二步按第一步操作。</p></li><li><p>已经提交了不合适的修改到版本库时，想要撤销本次提交，进行版本回退，前提是没有推送到远程库。</p></li></ol><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm &lt;file&gt;</span><br></pre></td></tr></table></figure><p><code>git rm &lt;file&gt;</code>相当于执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rm &lt;file&gt;</span><br><span class="line">$ git add &lt;file&gt;</span><br></pre></td></tr></table></figure></p><h4 id="进一步的解释"><a href="#进一步的解释" class="headerlink" title="进一步的解释"></a>进一步的解释</h4><p>Q：比如执行了<code>rm text.txt</code> 误删了怎么恢复？<br>A：执行<code>git checkout -- text.txt</code> 把版本库的东西重新写回工作区就行了<br>Q：如果执行了<code>git rm text.txt</code>我们会发现工作区的text.txt也删除了，怎么恢复？<br>A：先撤销暂存区修改，重新放回工作区，然后再从版本库写回到工作区<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset head text.txt</span><br><span class="line">$ git checkout -- text.txt</span><br></pre></td></tr></table></figure></p><p>Q：如果真的想从版本库里面删除文件怎么做？<br>A：执行<code>git commit -m &quot;delete text.txt&quot;</code>，提交后最新的版本库将不包含这个文件</p><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="创建SSH-Key"><a href="#创建SSH-Key" class="headerlink" title="创建SSH Key"></a>创建SSH Key</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span></span><br></pre></td></tr></table></figure><h4 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/username/repositoryname.git</span><br></pre></td></tr></table></figure><h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p><code>-u</code> 表示第一次推送master分支的所有内容，此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改。</p><h4 id="从远程克隆"><a href="#从远程克隆" class="headerlink" title="从远程克隆"></a>从远程克隆</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/usern/repositoryname.git</span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch &lt;branchname&gt;</span><br></pre></td></tr></table></figure><h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure><p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个*号。</p><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &lt;branchname&gt;</span><br></pre></td></tr></table></figure><h4 id="创建-切换分支"><a href="#创建-切换分支" class="headerlink" title="创建+切换分支"></a>创建+切换分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;branchname&gt;</span><br></pre></td></tr></table></figure><h4 id="合并某分支到当前分支"><a href="#合并某分支到当前分支" class="headerlink" title="合并某分支到当前分支"></a>合并某分支到当前分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge &lt;branchname&gt;</span><br></pre></td></tr></table></figure><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d &lt;branchname&gt;</span><br></pre></td></tr></table></figure><h4 id="查看分支合并图"><a href="#查看分支合并图" class="headerlink" title="查看分支合并图"></a>查看分支合并图</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph</span><br></pre></td></tr></table></figure><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。用<code>git log --graph</code>命令可以看到分支合并图。</p><h4 id="普通模式合并分支"><a href="#普通模式合并分支" class="headerlink" title="普通模式合并分支"></a>普通模式合并分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">"description"</span> &lt;branchname&gt;</span><br></pre></td></tr></table></figure><p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，能看出来曾经做过合并，包含作者和时间戳等信息，而fast forward合并就看不出来曾经做过合并。</p><h4 id="保存工作现场"><a href="#保存工作现场" class="headerlink" title="保存工作现场"></a>保存工作现场</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br></pre></td></tr></table></figure><h4 id="查看工作现场"><a href="#查看工作现场" class="headerlink" title="查看工作现场"></a>查看工作现场</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><h4 id="恢复工作现场"><a href="#恢复工作现场" class="headerlink" title="恢复工作现场"></a>恢复工作现场</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h4 id="丢弃一个没有合并过的分支"><a href="#丢弃一个没有合并过的分支" class="headerlink" title="丢弃一个没有合并过的分支"></a>丢弃一个没有合并过的分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D &lt;branchname&gt;</span><br></pre></td></tr></table></figure><h4 id="查看远程库信息"><a href="#查看远程库信息" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure><h4 id="在本地创建和远程分支对应的分支"><a href="#在本地创建和远程分支对应的分支" class="headerlink" title="在本地创建和远程分支对应的分支"></a>在本地创建和远程分支对应的分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b branch-name origin/branch-name，</span><br></pre></td></tr></table></figure><p>本地和远程分支的名称最好一致；</p><h4 id="建立本地分支和远程分支的关联"><a href="#建立本地分支和远程分支的关联" class="headerlink" title="建立本地分支和远程分支的关联"></a>建立本地分支和远程分支的关联</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream branch-name origin/branch-name；</span><br></pre></td></tr></table></figure><h4 id="从本地推送分支"><a href="#从本地推送分支" class="headerlink" title="从本地推送分支"></a>从本地推送分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin branch-name</span><br></pre></td></tr></table></figure><p>如果推送失败，先用git pull抓取远程的新提交；</p><h4 id="从远程抓取分支"><a href="#从远程抓取分支" class="headerlink" title="从远程抓取分支"></a>从远程抓取分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure><p>如果有冲突，要先处理冲突。</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><h4 id="新建一个标签"><a href="#新建一个标签" class="headerlink" title="新建一个标签"></a>新建一个标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag &lt;tagname&gt;</span><br></pre></td></tr></table></figure><p>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为HEAD，也可以指定一个commit id。</p><h4 id="指定标签信息"><a href="#指定标签信息" class="headerlink" title="指定标签信息"></a>指定标签信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id</span><br></pre></td></tr></table></figure><p><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息。</p><h4 id="PGP签名标签"><a href="#PGP签名标签" class="headerlink" title="PGP签名标签"></a>PGP签名标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -s &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id</span><br></pre></td></tr></table></figure><p><code>git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以用PGP签名标签。</p><h4 id="查看所有标签"><a href="#查看所有标签" class="headerlink" title="查看所有标签"></a>查看所有标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br></pre></td></tr></table></figure><h4 id="推送一个本地标签"><a href="#推送一个本地标签" class="headerlink" title="推送一个本地标签"></a>推送一个本地标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin &lt;tagname&gt;</span><br></pre></td></tr></table></figure><h4 id="推送全部未推送过的本地标签"><a href="#推送全部未推送过的本地标签" class="headerlink" title="推送全部未推送过的本地标签"></a>推送全部未推送过的本地标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure><h4 id="删除一个本地标签"><a href="#删除一个本地标签" class="headerlink" title="删除一个本地标签"></a>删除一个本地标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d &lt;tagname&gt;</span><br></pre></td></tr></table></figure><h4 id="删除一个远程标签"><a href="#删除一个远程标签" class="headerlink" title="删除一个远程标签"></a>删除一个远程标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/&lt;tagname&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;Git介绍&quot;&gt;&lt;a href=&quot;#Git介绍&quot; class=&quot;headerlink&quot; title=&quot;Git介绍&quot;&gt;&lt;/a&gt;Git介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Gi
      
    
    </summary>
    
      <category term="笔记" scheme="http://www.yuhongwa.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="http://www.yuhongwa.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo+GitHub Pages搭建个人博客</title>
    <link href="http://www.yuhongwa.com/2018/01/19/%E4%BD%BF%E7%94%A8Hexo-GitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://www.yuhongwa.com/2018/01/19/使用Hexo-GitHub-Pages搭建个人博客/</id>
    <published>2018-01-18T16:56:00.000Z</published>
    <updated>2018-01-18T21:51:25.730Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>本文主要用于记录自己搭建博客的过程。17年12月快期末的时候，萌生了下学期出去实习的想法，考试结束后这种想法愈发强烈，尝试写了简历之后很难受，发现没什么拿的出手的工作和项目，于是寒假这段时间想静下心来，先从个人博客开始，慢慢地学点知识，努力追赶优秀的吴大大、卜神、大仙等。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>需要准备两个软件：</p><ul><li>Git</li><li>Node.js</li></ul><p>我的操作系统是Win10  64位，Mac OS和Linux请参看其他安装方式。</p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>到<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">官网</a>下载Git安装文件，在“Adjusting your PATH environment”这一步时，选择第二项“User Git from the Windows Command Prompt”。<br>安装完成后，按Win+R打开运行窗口输入cmd并回车，打开命令行窗口，输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  --version</span><br></pre></td></tr></table></figure></p><p>如果结果会显示git 版本号，说明安装正确。</p><h3 id="配置Node-js环境"><a href="#配置Node-js环境" class="headerlink" title="配置Node.js环境"></a>配置Node.js环境</h3><p>到<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网</a>下载相应的Node.js文件，下载完成后打开，保持默认设置即可，一路Next。同样地，打开命令行窗口，依次输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></p><p>如果显示相应的版本号，说明安装正确。</p><h2 id="配置GitHub"><a href="#配置GitHub" class="headerlink" title="配置GitHub"></a>配置GitHub</h2><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>注册后登录，创建仓库(New repository)，其中repository name为yourname.github，Description不写也没关系。</p><h3 id="开启GitHub-Pages功能"><a href="#开启GitHub-Pages功能" class="headerlink" title="开启GitHub-Pages功能"></a>开启GitHub-Pages功能</h3><p>点击界面右侧的Setting，将会打开该仓库的setting界面，向下拖动直至看见GitHub Pages，点击“Automatic page generator”，GitHub将会自动创建gh-pages页面，过几分钟后，即可访问yourname.github.io这个网址。</p><h2 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h2><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>在自己觉得合适的地方创建一个文件夹，我在桌面上新建文件夹命名为Blog，进入该空白文件夹，在此处打开Git Bash，输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p><p>继续输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexp --save</span><br></pre></td></tr></table></figure></p><p>输入以下命令，如果显示hexo版本号说明安装成功<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure></p><h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h3><p>接着上面的操作继续输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure></p><p>其中blog文件夹即为本地仓库，与博客相关的配置和博文内容都在里面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></p><h2 id="体验Hexo"><a href="#体验Hexo" class="headerlink" title="体验Hexo"></a>体验Hexo</h2><p>继续操作，同样在Git Bash下，输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></p><p>然后，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexp d</span><br></pre></td></tr></table></figure></p><p>在浏览器中打开<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>，将会看到一个崭新的的博客页面。<br>若打不开，可能是因为端口被占用了，换个端口即可，执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server -p 5000</span><br></pre></td></tr></table></figure></p><p>上面的命令即换到端口5000，在浏览器中打开<a href="http://localhost:5000/" target="_blank" rel="noopener">http://localhost:5000/</a>即可。<br>到目前为止，Hexo在本地的配置全部结束。</p><h2 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a>使用Hexo</h2><h3 id="配置Deployment"><a href="#配置Deployment" class="headerlink" title="配置Deployment"></a>配置Deployment</h3><p>打开Git Bash，选择使用git方式进行部署，输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>首先需要为自己配置身份信息,输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"yourname"</span></span><br><span class="line">git config --global user.email <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure></p><p>同样在站点文件_config.yml，找到Deployment然后按照如下修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>然后在进入blog文件夹下，输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><p>接下来按照提示，分别输入自己的Github账号用户名和密码，然后就可以通过<a href="http://yourname.github.io/" target="_blank" rel="noopener">http://yourname.github.io/</a>来访问自己刚上传地网站了。</p><h3 id="添加新文章"><a href="#添加新文章" class="headerlink" title="添加新文章"></a>添加新文章</h3><p>打开blog目录下的source文件夹，再打开_posts文件夹，会看到一个初始的hello-world.md文件，这就是对应的博文。如果想添加新文章，直接在_posts文件夹下新建md类型的文档即可，重新执行hexo clean、hexo g和hexo d。</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>在本地ping yourname.github.io后会得到一个ip：xxx.xxx.xx.147，我在阿里云上买了一个域名yuhongwa.com，然后进行解析，添加三条条目如下：</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">主机记录</th><th style="text-align:center">记录值</th></tr></thead><tbody><tr><td style="text-align:center">CNAME</td><td style="text-align:center">@</td><td style="text-align:center">hongiii.github.io</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">@</td><td style="text-align:center">xxx.xxx.xx.147</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">@</td><td style="text-align:center">xxx.xxx.xx.148</td></tr></tbody></table><p>然后在blog目录下的source文件中华，新建一个CNAME文件，没有后缀名，内容为yourdomain.xxx，我的就是www.yuhongwa.com，然后执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure></p><p>重现上传自己的博客，登录Github打开yourname.github.io仓库，进入setting页面，如果在GitHub Pages下看到”Your site is published at <a href="https://www.yuhongwa.com">https://www.yuhongwa.com</a>“之类的提示，说明配置成功。</p><h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>Hexo默认采用landscape主题，如果想更换其他主题比如Next等，可以查到相应的主题下载到blog目录下的theme文件夹下，然后在站点配置文件_config.yml中修改，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: http://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: http://hexo.io/themes/</span></span><br><span class="line">theme: landscape //themes文件夹中对应文件夹的名称</span><br></pre></td></tr></table></figure></p><p>然后执行hexo clean，接着hexo g，最后hexo d，很快就可以看到新的主题样式了。</p><h3 id="其他个性化设置"><a href="#其他个性化设置" class="headerlink" title="其他个性化设置"></a>其他个性化设置</h3><p>这一部分我花费的时间比较长，参考了很多文章，个性化设置有很多，比如</p><ul><li>更改字体字号</li><li>头像设为圆形可旋转</li><li>动态页面</li><li>添加音乐</li><li>添加评论</li><li>添加打赏</li><li>添加浏览、访客之类</li><li>添加RSS等等</li></ul><p>实在太多了，我采用的主要有以下个性化设置：</p><h5 id="修改侧边栏为左侧"><a href="#修改侧边栏为左侧" class="headerlink" title="修改侧边栏为左侧"></a>修改侧边栏为左侧</h5><p>默认Next主题Mist风格，侧边栏是放在右边的，我想把它放在左侧。<br><a href="http://mashirosorata.vicp.io/HEXO-NEXT%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html" target="_blank" rel="noopener">参考</a></p><h5 id="修改字号"><a href="#修改字号" class="headerlink" title="修改字号"></a>修改字号</h5><p>我不记得默认的字号是14px还是16px，修改字号<a href="https://www.jianshu.com/p/02fbd409988c" target="_blank" rel="noopener">参考</a></p><h5 id="修改主题宽度"><a href="#修改主题宽度" class="headerlink" title="修改主题宽度"></a>修改主题宽度</h5><p>默认主题的留白太多，如果想修改页宽，减少两侧空白，可<a href="http://wanzhiyu.top/2017/01/20/%E6%95%99%E7%A8%8B/Hexo/Hexo-Next%E4%B8%BB%E9%A2%98%E5%AE%BD%E5%BA%A6%E8%B0%83%E8%8A%82/" target="_blank" rel="noopener">参考</a></p><h5 id="头像设为圆形，且点击可旋转"><a href="#头像设为圆形，且点击可旋转" class="headerlink" title="头像设为圆形，且点击可旋转"></a>头像设为圆形，且点击可旋转</h5><p><a href="http://blog.csdn.net/MasterAnt_D/article/details/56839222#t50" target="_blank" rel="noopener">参考</a><br>注意，如果想设置为圆形，采用的图片尽量为正方形，否则显示效果为椭圆。</p><h5 id="添加高冷的龙之介大人模型-live2d"><a href="#添加高冷的龙之介大人模型-live2d" class="headerlink" title="添加高冷的龙之介大人模型(live2d)"></a>添加高冷的龙之介大人模型(live2d)</h5><p><a href="http://wiggin.win/2017/08/30/hexo%E6%8F%92%E4%BB%B6%EF%BC%9ALive2D%20%E8%90%8C%E8%90%8C%E4%BA%8C%E6%AC%A1%E5%85%83/" target="_blank" rel="noopener">参考</a></p><h5 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h5><p>看很多人用的来必力之类的，我用的是<a href="http://www.uyan.cc/" target="_blank" rel="noopener">友言</a>，个人感觉友言挺好用的。</p><h5 id="添加打赏等"><a href="#添加打赏等" class="headerlink" title="添加打赏等"></a>添加打赏等</h5><p>以上两部分谷歌一下都有很多，不再赘述了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从开始搭建博客到完成，大概花了一周的时间，感觉大部分时间都用在个性化配置上面了，这里非常感谢很多很多的大佬们的文章和开源项目。<br>呐，小白龙要开始她的学习之旅啦~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;本文主要用于记录自己搭建博客的过程。17年12月快期末的时候，萌生了下学期出去实习的想法，考试结束后这种想法愈发强烈，尝试写了简历之后很难受，发现没什么拿的出手的工作和项目，
      
    
    </summary>
    
      <category term="记录" scheme="http://www.yuhongwa.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Hexo" scheme="http://www.yuhongwa.com/tags/Hexo/"/>
    
      <category term="Github Pages" scheme="http://www.yuhongwa.com/tags/Github-Pages/"/>
    
      <category term="博客搭建" scheme="http://www.yuhongwa.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
</feed>
