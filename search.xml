<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux系统调用]]></title>
    <url>%2F2018%2F05%2F12%2F%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[系统调用基本原理系统调用其实就是函数调用，区别是调用内核态的函数。但是用户态到内核态不是随意切换的，所以通过系统调用接口实现用户态到内核态的切换，在保护机制的计算机系统中，用户必须通过软件中断或陷入的方式使进程从用户态切换为内核态。在i386体系中，Linux系统调用接口是通过软中断指令int 0x80使进程从用户态进入内核态的，这个过程也叫“陷入”。系统调用接口调用软中断指令int 0x80的时候，这个指令会发生一个中断向量码为128的中断请求，并在响应过程中将进程从用户态切换为内核态。通过软中断0x80，系统会跳转到一个预设好的内核空间地址，它指向了系统调用处理程序，即在entry.S文件中的system_call函数。也就是，所有的系统调用都会统一跳转到这个地址执行system_call()函数。因为Linux只允许系统调用接口使用128这一个中断向量，并在中断号为128的中断服务例程中，调用不同调用不同的内核服务例程，所以，系统调用接口除了要引发int 0x80软中断外，为了进入内河后调用不同的内核服务例程，还需要提供识别内核服务例程的参数，称之为“系统调用号”。每个系统调用都有对应的系统调用号，同时内核中有一个system_call_table数组，它是个函数指针数组，每个函数指针都指向了系统调用的服务例程，下标就是该内核服务例程的系统调用号，用以指明到底执行哪个系统调用。当int 0x80软中断执行时，系统调用号会放入eax寄存器中，system_call函数可以读取eax寄存器获得系统调用号，将其乘以4得到偏移地址，以sys_call_table为基地址，基地址加上偏移地址就是应该执行的系统调用服务例程（内核服务例程）的地址。 系统调用参数传递参数依次存放在寄存器eax、ebx、ecx、edx、esi中，当系统调用的参数大于5个时（因为上面5个寄存器用完了），执行int 0x80执行仍需将系统调用功能号保存在eax中，所不同的只是参数应该依次存放在一块连续的内存区域内，同时在寄存器eax中保存指向该内存区域的指针。系统调用完成后，返回值仍将保存在寄存器eax中。由于只是需要一块连续的内存区域来保存系统调用的参数，因此可以完全像普通函数调用一样使用栈（Stack）来传递系统调用所需的参数。但是，注意参数以相反的顺序进栈，先进后出，即应该最后一个参数先进栈，第一个参数最后进栈。如果采用栈来传递系统调用所需要的参数，在执行int $0x80指令时还应该将栈指针的当前值复制到寄存器ebx中。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>中断</tag>
        <tag>系统调用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核：增加系统调用]]></title>
    <url>%2F2018%2F04%2F22%2FLinux%E5%86%85%E6%A0%B8%EF%BC%9A%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[系统调用是操作系统为用户态进程与硬件及内核资源进行交互提供的一组接口。本文主要介绍如何在VMWare虚拟机下向Linux内核增加系统调用，并进行简单测试的过程。对于不同的内核版本，实现方式略有不同，这里使用的是内核4.6.3。主要有以下6个步骤： 下载并解压内核、生成.config配置文件 在arch/x86/entry/syscalls/syscall_64.tbl中添加系统调用号 在kernel/sys.c中添加系统调用程序 在include/linux/syscalls.h中添加相应的声明 编译内核、安装内核 重启并测试 下载并解压内核、生成.config配置文件下载并解压内核在清华镜像下载linux-4.6.3，解压至/usr/src，1sudo tar -xvf linux-4.6.3.tar.gz 进入该文件夹，1cd /usr/src/linux-4.6.3 生成.config配置文件.config文件是Linux内核的配置文件，执行make bzImage生成新内核的时候，顶层的Makefile文件会读取.config文件中的内容，根据这个文件编译定制的内核。首先将原来的配置文件拷贝过来，到/usr/src文件夹下，使用uname -r查看内核版本，当前的Ubuntu内核版本是4.10.0-30，配置文件是/usr/src/linux-headers-4.10.0-30-generic/.config 这个文件，执行如下命令生成临时.config配置文件：1sudo cp /usr/src/linux-headers-4.10.0-30-generic/.config .config 其他安装12sudo apt-get install libssl-devsudo apt-get install libncurses5-dev 其中libncurses5-dev安装menuconfig，与屏幕显示和游标移动相关。 添加系统调用号在arch/x86/entry/syscalls/syscall_64.tbl文件中，向最后一行添加自己的系统调用，如下1546 common lsproc sys_lsproc 添加系统调用程序在kernel/sys.c文件中，添加系统调用程序，12345asmlinkage int sys_lsproc (int num)&#123; printk("Hi, this is yuhong's syscall\n"); return 1;&#125; 添加相应声明在include/linux/syscalls.h中添加函数声明，1asmlinkage int sys_lsproc(int num); 编译内核、安装内核执行1sudo make menuconfig 选择Load，然后Ok，保存并退出。然后依次执行，1234make bzImage //生成新内核make modules //编译模块make modules_install //安装模块make install //安装内核 重启并测试安装完成之后重启虚拟机，按ESC进入Ubuntu Grub界面，选择高级选项，选择4.6.3内核。新建测试文件test.c，内容为：12345678#include &lt;linux/unistd.h&gt;#include &lt;sys/syscall.h&gt;int main()&#123; syscall(546, 1); //依次是调用号和参数 return 0;&#125; 编译并运行，输出这里提示implicit declaration of function ‘syscall’，经查暂无果。dmesg查看系统缓冲区以获取最近输出的诊断消息并在标准输出中输出这些消息。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>系统调用</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu make menuconfig error]]></title>
    <url>%2F2018%2F03%2F02%2F%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[1234567891011root@ubuntu:/home/linux/linux-4.15.6# make menuconfig *** Unable to find the ncurses libraries or the *** required header files. *** 'make menuconfig' requires the ncurses libraries. *** *** Install ncurses (ncurses-devel) and try again. ***scripts/kconfig/Makefile:202: recipe for target 'scripts/kconfig/dochecklxdialog' failedmake[1]: *** [scripts/kconfig/dochecklxdialog] Error 1Makefile:505: recipe for target 'menuconfig' failedmake: *** [menuconfig] Error 2 solution:1apt-get install libncurses5 libncurses5-dev]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>内核编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git笔记]]></title>
    <url>%2F2018%2F01%2F23%2FGit%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Git介绍 Git是分布式版本控制系统 集中式VS分布式，SVN VS Git1）SVN和Git主要的区别在于历史版本维护的位置2）Git本地仓库包含代码库还有历史库，在本地的环境开发就可以记录历史而SVN的历史库存在于中央仓库，每次对比与提交代码都必须连接到中央仓库才能进行。3）这样的好处在于： 自己可以在脱机环境查看开发的版本历史。 多人开发时如果充当中央仓库的Git仓库挂了，可以随时创建一个新的中央仓库然后同步就立刻恢复了中央库。 Git命令Git配置12$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com" git config命令的--global参数，表明这台机器上的所有Git仓库都会使用这个配置，也可以对某个仓库指定不同的用户名和邮箱地址。 创建版本库初始化一个Git仓库1$ git init 添加文件到Git仓库包括两步：12$ git add &lt;file&gt;$ git commit -m "description" git add可以反复多次使用，添加多个文件，git commit可以一次提交很多文件，-m后面输入的是本次提交的说明，可以输入任意内容。 查看工作区状态1$ git status 查看修改内容1$ git diff 1$ git diff --cached 1$ git diff HEAD -- &lt;file&gt; git diff 可以查看工作区(work dict)和暂存区(stage)的区别 git diff --cached 可以查看暂存区(stage)和分支(master)的区别 git diff HEAD -- &lt;file&gt; 可以查看工作区和版本库里面最新版本的区别查看提交日志1$ git log 简化日志输出信息1$ git log --pretty=oneline 查看命令历史1$ git reflog 版本回退1$ git reset --hard HEAD^ 以上命令是返回上一个版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本是HEAD^^，往上100个版本写成HEAD~100。 回退指定版本号1$ git reset --hard commit_id commit_id是版本号，是一个用SHA1计算出的序列 工作区、暂存区和版本库工作区：在电脑里能看到的目录；版本库：在工作区有一个隐藏目录.git，是Git的版本库。Git的版本库中存了很多东西，其中最重要的就是称为stage（或者称为index）的暂存区，还有Git自动创建的master，以及指向master的指针HEAD。 进一步解释一些命令： git add实际上是把文件添加到暂存区 git commit实际上是把暂存区的所有内容提交到当前分支撤销修改丢弃工作区的修改1$ git checkout -- &lt;file&gt; 该命令是指将文件在工作区的修改全部撤销，这里有两种情况： 一种是file自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是file已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 丢弃暂存区的修改分两步：第一步，把暂存区的修改撤销掉(unstage)，重新放回工作区：1$ git reset HEAD &lt;file&gt; 第二步，撤销工作区的修改1$ git checkout -- &lt;file&gt; 小结： 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- &lt;file&gt;。 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了第一步，第二步按第一步操作。 已经提交了不合适的修改到版本库时，想要撤销本次提交，进行版本回退，前提是没有推送到远程库。 删除文件1$ git rm &lt;file&gt; git rm &lt;file&gt;相当于执行12$ rm &lt;file&gt;$ git add &lt;file&gt; 进一步的解释Q：比如执行了rm text.txt 误删了怎么恢复？A：执行git checkout -- text.txt 把版本库的东西重新写回工作区就行了Q：如果执行了git rm text.txt我们会发现工作区的text.txt也删除了，怎么恢复？A：先撤销暂存区修改，重新放回工作区，然后再从版本库写回到工作区12$ git reset head text.txt$ git checkout -- text.txt Q：如果真的想从版本库里面删除文件怎么做？A：执行git commit -m &quot;delete text.txt&quot;，提交后最新的版本库将不包含这个文件 远程仓库创建SSH Key1$ ssh-keygen -t rsa -C "youremail@example.com" 关联远程仓库1$ git remote add origin https://github.com/username/repositoryname.git 推送到远程仓库1$ git push -u origin master -u 表示第一次推送master分支的所有内容，此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改。 从远程克隆1$ git clone https://github.com/usern/repositoryname.git 分支创建分支1$ git branch &lt;branchname&gt; 查看分支1$ git branch git branch命令会列出所有分支，当前分支前面会标一个*号。 切换分支1$ git checkout &lt;branchname&gt; 创建+切换分支1$ git checkout -b &lt;branchname&gt; 合并某分支到当前分支1$ git merge &lt;branchname&gt; 删除分支1$ git branch -d &lt;branchname&gt; 查看分支合并图1$ git log --graph 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。用git log --graph命令可以看到分支合并图。 普通模式合并分支1$ git merge --no-ff -m "description" &lt;branchname&gt; 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。合并分支时，加上--no-ff参数就可以用普通模式合并，能看出来曾经做过合并，包含作者和时间戳等信息，而fast forward合并就看不出来曾经做过合并。 保存工作现场1$ git stash 查看工作现场1$ git stash list 恢复工作现场1$ git stash pop 丢弃一个没有合并过的分支1$ git branch -D &lt;branchname&gt; 查看远程库信息1$ git remote -v 在本地创建和远程分支对应的分支1$ git checkout -b branch-name origin/branch-name， 本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联1$ git branch --set-upstream branch-name origin/branch-name； 从本地推送分支1$ git push origin branch-name 如果推送失败，先用git pull抓取远程的新提交； 从远程抓取分支1$ git pull 如果有冲突，要先处理冲突。 标签tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。 新建一个标签1$ git tag &lt;tagname&gt; 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id。 指定标签信息1$ git tag -a &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息。 PGP签名标签1$ git tag -s &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;可以用PGP签名标签。 查看所有标签1$ git tag 推送一个本地标签1$ git push origin &lt;tagname&gt; 推送全部未推送过的本地标签1$ git push origin --tags 删除一个本地标签1$ git tag -d &lt;tagname&gt; 删除一个远程标签1$ git push origin :refs/tags/&lt;tagname&gt;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo+GitHub Pages搭建个人博客]]></title>
    <url>%2F2018%2F01%2F19%2F%E4%BD%BF%E7%94%A8Hexo-GitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[本文主要用于记录自己搭建博客的过程。17年12月快期末的时候，萌生了下学期出去实习的想法，考试结束后这种想法愈发强烈，尝试写了简历之后很难受，发现没什么拿的出手的工作和项目，于是寒假这段时间想静下心来，先从个人博客开始，慢慢地学点知识，努力追赶优秀的吴大大、卜神、大仙等。 准备需要准备两个软件： Git Node.js 我的操作系统是Win10 64位，Mac OS和Linux请参看其他安装方式。 安装Git到官网下载Git安装文件，在“Adjusting your PATH environment”这一步时，选择第二项“User Git from the Windows Command Prompt”。安装完成后，按Win+R打开运行窗口输入cmd并回车，打开命令行窗口，输入1git --version 如果结果会显示git 版本号，说明安装正确。 配置Node.js环境到官网下载相应的Node.js文件，下载完成后打开，保持默认设置即可，一路Next。同样地，打开命令行窗口，依次输入12node -vnpm -v 如果显示相应的版本号，说明安装正确。 配置GitHub创建仓库注册后登录，创建仓库(New repository)，其中repository name为yourname.github，Description不写也没关系。 开启GitHub-Pages功能点击界面右侧的Setting，将会打开该仓库的setting界面，向下拖动直至看见GitHub Pages，点击“Automatic page generator”，GitHub将会自动创建gh-pages页面，过几分钟后，即可访问yourname.github.io这个网址。 配置Hexo安装Hexo在自己觉得合适的地方创建一个文件夹，我在桌面上新建文件夹命名为Blog，进入该空白文件夹，在此处打开Git Bash，输入1npm install hexo-cli -g 继续输入1npm install hexp --save 输入以下命令，如果显示hexo版本号说明安装成功1hexo -v 初始化Hexo接着上面的操作继续输入1hexo init blog 其中blog文件夹即为本地仓库，与博客相关的配置和博文内容都在里面1npm install 体验Hexo继续操作，同样在Git Bash下，输入1hexo g 然后，1hexp d 在浏览器中打开http://localhost:4000/，将会看到一个崭新的的博客页面。若打不开，可能是因为端口被占用了，换个端口即可，执行命令1hexo server -p 5000 上面的命令即换到端口5000，在浏览器中打开http://localhost:5000/即可。到目前为止，Hexo在本地的配置全部结束。 使用Hexo配置Deployment打开Git Bash，选择使用git方式进行部署，输入1npm install hexo-deployer-git --save 首先需要为自己配置身份信息,输入12git config --global user.name "yourname"git config --global user.email "youremail" 同样在站点文件_config.yml，找到Deployment然后按照如下修改1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 然后在进入blog文件夹下，输入1hexo d 接下来按照提示，分别输入自己的Github账号用户名和密码，然后就可以通过http://yourname.github.io/来访问自己刚上传地网站了。 添加新文章打开blog目录下的source文件夹，再打开_posts文件夹，会看到一个初始的hello-world.md文件，这就是对应的博文。如果想添加新文章，直接在_posts文件夹下新建md类型的文档即可，重新执行hexo clean、hexo g和hexo d。 进阶绑定域名在本地ping yourname.github.io后会得到一个ip：xxx.xxx.xx.147，我在阿里云上买了一个域名yuhongwa.com，然后进行解析，添加三条条目如下： 类型 主机记录 记录值 CNAME @ hongiii.github.io A @ xxx.xxx.xx.147 A @ xxx.xxx.xx.148 然后在blog目录下的source文件中华，新建一个CNAME文件，没有后缀名，内容为yourdomain.xxx，我的就是www.yuhongwa.com，然后执行1hexo d -g 重现上传自己的博客，登录Github打开yourname.github.io仓库，进入setting页面，如果在GitHub Pages下看到”Your site is published at https://www.yuhongwa.com“之类的提示，说明配置成功。 修改主题Hexo默认采用landscape主题，如果想更换其他主题比如Next等，可以查到相应的主题下载到blog目录下的theme文件夹下，然后在站点配置文件_config.yml中修改，1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: landscape //themes文件夹中对应文件夹的名称 然后执行hexo clean，接着hexo g，最后hexo d，很快就可以看到新的主题样式了。 其他个性化设置这一部分我花费的时间比较长，参考了很多文章，个性化设置有很多，比如 更改字体字号 头像设为圆形可旋转 动态页面 添加音乐 添加评论 添加打赏 添加浏览、访客之类 添加RSS等等 实在太多了，我采用的主要有以下个性化设置： 修改侧边栏为左侧默认Next主题Mist风格，侧边栏是放在右边的，我想把它放在左侧。参考 修改字号我不记得默认的字号是14px还是16px，修改字号参考 修改主题宽度默认主题的留白太多，如果想修改页宽，减少两侧空白，可参考 头像设为圆形，且点击可旋转参考注意，如果想设置为圆形，采用的图片尽量为正方形，否则显示效果为椭圆。 添加高冷的龙之介大人模型(live2d)参考 添加评论看很多人用的来必力之类的，我用的是友言，个人感觉友言挺好用的。 添加打赏等以上两部分谷歌一下都有很多，不再赘述了。 总结从开始搭建博客到完成，大概花了一周的时间，感觉大部分时间都用在个性化配置上面了，这里非常感谢很多很多的大佬们的文章和开源项目。呐，小白龙要开始她的学习之旅啦~]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github Pages</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
